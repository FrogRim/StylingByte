# -*- coding: utf-8 -*-
"""UTKFACE_DATA_AGE_GENDER_PREDICT.ipynb의 사본

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1PYrObHWmjZ6Bo0Bikmdx0Jx7yVbmMonQ
"""

!pip install kaggle

from google.colab import files
files.upload()

ls -1ha kaggle.json

!mkdir -p ~/.kaggle
!cp kaggle.json ~/.kaggle/
# Permission Warning 이 일어나지 않도록
!chmod 600 ~/.kaggle/kaggle.json

#dataset down!
!kaggle datasets download -d jangedoo/utkface-new

!unzip /content/utkface-new.zip

files.upload()

import pandas as pd
import numpy as np
import os
import matplotlib.pyplot as plt
import cv2
from tensorflow.keras.models import Model, Sequential, load_model
from tensorflow.keras.layers import BatchNormalization, Conv2D, MaxPool2D, Activation, Dropout, Lambda, Dense, Flatten, Input
import tensorflow as tf
import tensorflow.keras as keras
from tensorflow.keras.callbacks import EarlyStopping
from sklearn.model_selection import train_test_split
from tqdm import tqdm
from tensorflow.keras import backend as k
from glob import glob
import seaborn as sns

folder_name = 'UTKFace'

dataset_dict = {
    'race_id': {
        0: 'white',
        1: 'black',
        2: 'asian',
        3: 'indian',
        4: 'others'
    },
    'gender_id': {
        0: 'male',
        1: 'female'
    }
}

dataset_dict['gender_alias'] = dict((g, i) for i, g in dataset_dict['gender_id'].items())
dataset_dict['race_alias'] = dict((g, i) for i, g in dataset_dict['race_id'].items())

def parse_dataset(dataset_path, ext='jpg'):

    def parse_info_from_file(path):
        try:
            filename = os.path.split(path)[1]
            filename = os.path.splitext(filename)[0]
            age, gender, race, _ = filename.split('_')

            return int(age), dataset_dict['gender_id'][int(gender)], dataset_dict['race_id'][int(race)]
        except Exception as ex:
            return None, None, None

    files = glob(os.path.join(dataset_path, "*.%s" % ext))

    records = []
    for file in files:
        info = parse_info_from_file(file)
        records.append(info)

    df = pd.DataFrame(records)
    df['file'] = files
    df.columns = ['age', 'gender', 'race', 'file']
    df = df.dropna()

    return df

df = parse_dataset(folder_name)

df.head()

import plotly.graph_objects as go

def plot_distribution(pd_series):
    labels = pd_series.value_counts().index.tolist()
    counts = pd_series.value_counts().values.tolist()

    pie_plot = go.Pie(labels=labels, values=counts, hole=.3)
    fig = go.Figure(data=[pie_plot])
    fig.update_layout(title_text='Distribution for %s' % pd_series.name)

    fig.show()

plot_distribution(df['race'])

plot_distribution(df['gender'])

bins = [0, 10, 20, 30, 40, 60, 80, np.inf]
names = ['<10', '10-20', '20-30', '30-40', '40-60', '60-80', '80+']
age_binned = pd.cut(df['age'], bins, labels=names)
plot_distribution(age_binned)

import math
n=16
random_indices = np.random.choice(df.index.tolist(), size=n)
n_cols = 4
n_rows = math.ceil(n / n_cols)
fig, axes = plt.subplots(n_rows, n_cols, figsize=(15, 17))
for i, x in enumerate(random_indices):
   ax = axes.flat[i]
   img = cv2.imread(df['file'][x])
   img = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)
   ax.imshow(img)
   pic_age = df['age'][x]
   pic_gender = df['gender'][x]
   pic_race = df['race'][x]
   ax.set_xlabel('age: {}, gender: {}, race: {}'.format(int(pic_age),pic_gender, pic_race))

images = []
age = []
gender = []
for img in os.listdir(folder_name):
  ages = img.split("_")[0]
  genders = img.split("_")[1]
  img = cv2.imread(str(folder_name)+"/"+str(img))
  img = cv2.cvtColor(img,cv2.COLOR_BGR2RGB)
  img = img
  images.append(np.array(img))
  age.append(np.array(ages))
  gender.append(np.array(genders))

age = np.array(age,dtype=np.int64)
images = np.array(images)
gender = np.array(gender,np.uint64)

x_train_age, x_test_age, y_train_age, y_test_age = train_test_split(images, age, random_state=42, test_size=0.4)
x_valid_age , x_test_age  , y_valid_age, y_test_age = train_test_split(x_test_age, y_test_age, random_state=42, test_size=0.5)

x_train_gender, x_test_gender, y_train_gender, y_test_gender = train_test_split(images, gender, random_state=42, test_size = 0.4)
x_valid_gender , x_test_gender  , y_valid_gender, y_test_gender = train_test_split(x_test_gender, y_test_gender, random_state=42, test_size=0.5)

from tensorflow.keras.optimizers import Adam
init_lr = 1e-4
epochs = 50
opt = Adam(lr=init_lr, decay=init_lr / epochs)

age_model = Sequential([
    Conv2D(128, kernel_size =3, input_shape=(200,200,3)),
    BatchNormalization(),
    Activation('relu'),
    MaxPool2D(pool_size=3, strides=2),
    Conv2D(128, kernel_size =3),
    BatchNormalization(),
    Activation('relu'),
    MaxPool2D(pool_size=3, strides=2),
    Conv2D(256, kernel_size =3),
    BatchNormalization(),
    Activation('relu'),
    MaxPool2D(pool_size=3, strides=2),
    Conv2D(512, kernel_size =3),
    BatchNormalization(),
    Activation('relu'),
    MaxPool2D(pool_size=3, strides=2),
    Flatten(),
    Dropout(0.25),
    Dense(512, activation  = 'relu'),
    Dense(1, activation = 'linear', name = 'age')
])
age_model.compile(loss="mse", optimizer=opt, metrics = ['mae'])

gender_model = Sequential([
    Conv2D(36, kernel_size=3,input_shape=(200,200,3)),
    BatchNormalization(),
    Activation('relu'),
    MaxPool2D(pool_size=3, strides=2),
    Conv2D(64, kernel_size=3),
    BatchNormalization(),
    Activation('relu'),
    MaxPool2D(pool_size=3, strides=2),
    Conv2D(128, kernel_size=3),
    BatchNormalization(),
    Activation('relu'),
    MaxPool2D(pool_size=3, strides=2),
    Conv2D(256, kernel_size=3),
    BatchNormalization(),
    Activation('relu'),
    MaxPool2D(pool_size=3, strides=2),
    Conv2D(512, kernel_size=3),
    BatchNormalization(),
    Activation('relu'),
    MaxPool2D(pool_size=3, strides=2),
    Flatten(),
    Dropout(0.25),
    Dense(512, activation  = 'relu'),
    Dense(1, activation = 'sigmoid', name = 'gender')
])

gender_model.compile(optimizer=opt, loss='binary_crossentropy', metrics=['accuracy'])

from tensorflow.keras.callbacks import ModelCheckpoint

callbacks = [EarlyStopping(monitor='val_loss',
                                           patience=5),
             ModelCheckpoint(filepath='./best_model_{val_loss:.2f}.h5',
                                             monitor='val_loss',
                                             save_best_only=True)]

history_age = age_model.fit(x_train_age, y_train_age,
                        validation_data=(x_valid_age, y_valid_age), batch_size = 32, epochs=50, callbacks = callbacks)

age_model.save('age_model.h5')

history_gender = gender_model.fit(x_train_gender, y_train_gender,
                        validation_data=(x_valid_gender, y_valid_gender), batch_size=32, callbacks = callbacks, epochs=50)

gender_model.save('gender_model.h5')

from google.colab import files

files.download('gender_model.h5')

history_age

history = history_age
loss = history.history['loss']
val_loss = history.history['val_loss']
epochs = range(1, len(loss) + 1)
plt.plot(epochs, loss, 'y', label='Training loss')
plt.plot(epochs, val_loss, 'r', label='Validation loss')
plt.title('Age model Training and validation loss')
plt.xlabel('Epochs')
plt.ylabel('Loss')
plt.ylim(0,300)
plt.legend()
plt.show()

history = history_gender
loss = history.history['loss']
val_loss = history.history['val_loss']
epochs = range(1, len(loss) + 1)
plt.plot(epochs, loss, 'y', label='Training loss')
plt.plot(epochs, val_loss, 'r', label='Validation loss')
plt.title('Gender Training and validation loss')
plt.xlabel('Epochs')
plt.ylabel('Loss')
plt.legend()
plt.show()

len(x_test_age)

y_test_age[0]

age_preds = age_model.predict(x_test_age)

gender_preds = gender_model.predict(x_test_gender)

from sklearn.metrics import mean_absolute_error, accuracy_score, recall_score, precision_score, confusion_matrix, classification_report

age_mae = mean_absolute_error(y_test_age, age_preds)

age_mae

gender_accuracy = accuracy_score(y_test_gender, np.round(gender_preds))

gender_accuracy

plt.hist(gender_preds.ravel())

print(classification_report(y_test_gender,np.round(gender_preds)))

confusion_matrix(y_test_gender,np.round(gender_preds))

import math
n=16
random_indices = np.random.choice(len(x_test_age), size=n)
n_cols = 4
n_rows = math.ceil(n / n_cols)
fig, axes = plt.subplots(n_rows, n_cols, figsize=(15, 17))
for i, x in enumerate(random_indices):
   ax = axes.flat[i]
   ax.imshow(x_test_age[x])
   real_age = y_test_age[x]
   predict_age = age_preds[x]
   if y_test_gender[x] == 1:
     real_gender = 'female'
   else:
     real_gender = 'male'
   if np.round(gender_preds[x]) == 1:
     predict_gender = 'female'
   else:
     predict_gender ='male'
   ax.set_title('real_age: {}, real_gender: {}'.format(int(real_age),real_gender))
   ax.set_xlabel('predict_age: {}, predict_gender: {}'.format(int(predict_age),predict_gender))
   ax.xaxis.label.set_color('red')

